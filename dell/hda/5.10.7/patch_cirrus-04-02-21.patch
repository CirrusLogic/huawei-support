--- ./pub/linux-5.10.7/sound/pci/hda/patch_cirrus.c	2021-01-12 19:18:27.000000000 +0000
+++ ./linux-5.10.7/sound/pci/hda/patch_cirrus.c	2021-02-04 18:41:46.034730587 +0000
@@ -9,6 +9,8 @@
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <sound/core.h>
+#include <linux/mutex.h>
+#include <linux/pci.h>
 #include <sound/tlv.h>
 #include <sound/hda_codec.h>
 #include "hda_local.h"
@@ -18,6 +20,11 @@
 
 /*
  */
+struct unsol_item {
+        struct list_head list;
+        unsigned int idx;
+        unsigned int res;
+};
 
 struct cs_spec {
 	struct hda_gen_spec gen;
@@ -34,9 +41,19 @@
 	unsigned int sense_b:1;
 	hda_nid_t vendor_nid;
 
+    /* digital beep */
+    hda_nid_t beep_nid;
+
 	/* for MBP SPDIF control */
 	int (*spdif_sw_put)(struct snd_kcontrol *kcontrol,
 			    struct snd_ctl_elem_value *ucontrol);
+
+	unsigned int hs_adc_boost;
+	unsigned int hs_adc_volume;
+	unsigned int ts_invert;
+	unsigned int pcm_playback;
+	unsigned int pcm_capture;
+	unsigned int hs_jack;
 };
 
 /* available models with CS420x */
@@ -125,6 +142,10 @@
 /* Cirrus Logic CS4213 is like CS4210 but does not have SPDIF input/output */
 #define CS4213_VENDOR_NID	0x09
 
+/* CS8409 */
+#define CS8409_IDX_DEV_CFG     0x01
+#define CS8409_VENDOR_NID      0x47
+#define CS8409_BEEP_NID        0x46
 
 static inline int cs_vendor_coef_get(struct hda_codec *codec, unsigned int idx)
 {
@@ -327,6 +348,8 @@
 {
 	int err;
 
+	codec_info(codec, "%s()\n", __func__);
+
 	err = snd_hda_gen_build_controls(codec);
 	if (err < 0)
 		return err;
@@ -1219,6 +1242,953 @@
 	return err;
 }
 
+/*
+ * Cirrus Logic CS8409 HDA bridge and CS42L42 slave codec
+ *
+ */
+
+#define CS8409_VER_DEBUG  1
+
+enum {
+	DELL_BULLSEYE,
+	DELL_WARLOCK,
+	DELL_CYBORG,
+	UPXTREME_CDB42L42,
+	CS8409_VERBS,
+};
+
+/* CS8409/CS42L42 variants */
+static const struct hda_model_fixup cs8409_models[] = {
+	{ .id = DELL_BULLSEYE, .name = "bulleseye" },
+	{ .id = DELL_WARLOCK, .name = "warlock" },
+	{ .id = DELL_CYBORG, .name = "cyborg" },
+	{ .id = UPXTREME_CDB42L42, .name = "upxtreme" },
+	{}
+};
+
+/*
+ * TODO: Not sure what values should be there for DELL platforms
+ * It works on UPXtreme development board
+ * */
+static const struct snd_pci_quirk cs8409_fixup_tbl[] = {
+	/* Known Bulleseye models from INF file */
+	SND_PCI_QUIRK(0x1028, 0x0A11, "Bullseye V3 14 AMD", DELL_BULLSEYE),
+	SND_PCI_QUIRK(0x1028, 0x0A12, "Bullseye N3 15 AMD", DELL_BULLSEYE),
+	SND_PCI_QUIRK(0x1028, 0x0A23, "Bullseye V3 14 TGL", DELL_BULLSEYE),
+	SND_PCI_QUIRK(0x1028, 0x0A24, "Bullseye V3 15 TGL", DELL_BULLSEYE),
+	SND_PCI_QUIRK(0x1028, 0x0A25, "Bullseye N3 15 TGL", DELL_BULLSEYE),
+	SND_PCI_QUIRK(0x1028, 0x0A29, "Bullseye V3 14 ICL", DELL_BULLSEYE),
+	SND_PCI_QUIRK(0x1028, 0x0A2A, "Bullseye V3 15 ICL", DELL_BULLSEYE),
+	SND_PCI_QUIRK(0x1028, 0x0A2B, "Bullseye N3 15 ICL", DELL_BULLSEYE),
+	/* Subvendor, Subdevice */
+	SND_PCI_QUIRK(0x1013, 0x8409, "Dell Bullseye GN", DELL_BULLSEYE),
+	SND_PCI_QUIRK(0x1028, 0x8409, "Dell Bullseye GN", DELL_BULLSEYE),
+	/* Known Warlock models from INF file */
+	SND_PCI_QUIRK(0x1028, 0x0AB0, "Warlock N3 15 TGL", DELL_WARLOCK),
+	SND_PCI_QUIRK(0x1028, 0x0AB2, "Warlock V3 15 TGL", DELL_WARLOCK),
+	SND_PCI_QUIRK(0x1028, 0x0AB1, "Warlock N3 15 ICL", DELL_WARLOCK),
+	SND_PCI_QUIRK(0x1028, 0x0AB3, "Warlock V3 15 ICL", DELL_WARLOCK),
+	SND_PCI_QUIRK(0x1028, 0x0AB4, "Warlock N3 15 AMD", DELL_WARLOCK),
+	SND_PCI_QUIRK(0x1028, 0x0AB5, "Warlock V3 15 AMD", DELL_WARLOCK),
+	SND_PCI_QUIRK(0x1028, 0x0AD9, "Warlock N3 15 TGL-U", DELL_WARLOCK),
+	SND_PCI_QUIRK(0x1028, 0x0ADA, "Warlock N3 15 ICL-U", DELL_WARLOCK),
+	SND_PCI_QUIRK(0x1028, 0x0ADB, "Warlock V3 15 TGL-U", DELL_WARLOCK),
+	SND_PCI_QUIRK(0x1028, 0x0ADC, "Warlock V3 15 ICL-U", DELL_WARLOCK),
+	/* Subvendor Subdevice */
+	SND_PCI_QUIRK(0x1013, 0x8409, "Dell Warlock GN", DELL_WARLOCK),
+	SND_PCI_QUIRK(0x1028, 0x8409, "Dell Warlock GN", DELL_WARLOCK),
+	/* Known Cyborg models from INF file */
+	SND_PCI_QUIRK(0x1028, 0x0A77, "Cyborg N 14 AMD", DELL_CYBORG),
+	SND_PCI_QUIRK(0x1028, 0x0A78, "Cyborg N 15 AMD", DELL_CYBORG),
+	SND_PCI_QUIRK(0x1028, 0x0A79, "Cyborg V 14 AMD", DELL_CYBORG),
+	SND_PCI_QUIRK(0x1028, 0x0A7A, "Cyborg V 15 AMD", DELL_CYBORG),
+	SND_PCI_QUIRK(0x1028, 0x0A7D, "Cyborg N 14 TGL", DELL_CYBORG),
+	SND_PCI_QUIRK(0x1028, 0x0A7E, "Cyborg N 15 TGL", DELL_CYBORG),
+	SND_PCI_QUIRK(0x1028, 0x0A7F, "Cyborg V 14 TGL", DELL_CYBORG),
+	SND_PCI_QUIRK(0x1028, 0x0A80, "Cyborg V 15 TGL", DELL_CYBORG),
+	/* Subvendor Subdevice */
+	SND_PCI_QUIRK(0x1013, 0x8409, "Dell Cyborg GN", DELL_CYBORG),
+	SND_PCI_QUIRK(0x1028, 0x8409, "Dell Cyborg GN", DELL_CYBORG),
+	/* UPXtreme development board */
+	SND_PCI_QUIRK(0x1013, 0x8409, "UPXtreme", UPXTREME_CDB42L42),
+	SND_PCI_QUIRK_VENDOR(0x1028, "Dell", DELL_BULLSEYE),
+	{} /* terminator */
+};
+
+static struct mutex i2cm;
+static struct mutex pcmm;
+
+#define CS42L42_I2C_ADDR	(0x48 << 1)
+#define AMPL_I2C_ADDR		(0x50 << 1)
+#define AMPR_I2C_ADDR		(0x52 << 1)
+
+struct cs8409_i2c_param {
+	unsigned int addr;
+	unsigned int reg;
+};
+
+struct cs8409_vpw_param {
+	unsigned int nid;
+	unsigned int cir;
+	unsigned int coeff;
+};
+
+/* Initial configuration */
+static const struct hda_verb cs8409_init_verbs[] = {
+	{0x01, AC_VERB_SET_POWER_STATE, 0x00000000 }, 	 /* AFG: D0 */
+	{0x01, AC_VERB_SET_GPIO_DIRECTION, 0x00000020 }, /* GPIO5 out, GPIO 3,4,2,1,0 in */
+	{0x01, AC_VERB_SET_GPIO_DATA,  0x00000000 },  	 /* GPIO's data 0 */
+	{0x01, AC_VERB_SET_GPIO_MASK,  0x0000003f },  	 /* Enable GPIO 0,1,2,3,4,5 */
+	{0x01, AC_VERB_SET_GPIO_WAKE_MASK, 0x00000018},  /* Enable WAKE from GPIO 3,4 */
+	{0x47, AC_VERB_SET_PROC_STATE, 0x00000001 }, 	 /* VPW: processing on */
+	{0x47, AC_VERB_SET_COEF_INDEX, 0x00000002 }, 	 /* Configure GPIO6/7 */
+	{0x47, AC_VERB_SET_PROC_COEF,  0x00000080 },  	 /* GPIO6/7 I2C mode */
+	{0x47, AC_VERB_SET_COEF_INDEX, 0x0000005b }, 	 /* Set I2C bus speed *400KHz */
+	{0x47, AC_VERB_SET_PROC_COEF,  0x00000010 },
+	{} /* terminator */
+};
+
+/* CS8409 pin configuration  */
+static const struct hda_pintbl cs8409_pincfgs[] = {
+	{ 0x24, 0x042120f0 }, /* ASP-1-TX */
+	{ 0x34, 0x04a120f0 }, /* ASP-1-RX */
+	{ 0x2c, 0x901000f0 }, /* ASP-2-TX */
+	{ 0x44, 0x90a000f0 }, /* DMIC-1 */
+	{} /* terminator */
+};
+
+static const struct hda_verb cs8409_verbs[] = {
+	{0x24, 0x71c, 0xF0}, /* Widget node ASP-1-TX */
+	{0x24, 0x71d, 0x20},
+	{0x24, 0x71e, 0x21},
+	{0x24, 0x71f, 0x04},
+	{0x34, 0x71c, 0xf0}, /* Widget node ASP-1-RX0 */
+	{0x34, 0x71d, 0x20},
+	{0x34, 0x71e, 0xa1},
+	{0x34, 0x71f, 0x04},
+	{0x2C, 0x71c, 0xF0}, /* Widget node ASP-2-TX */
+	{0x2C, 0x71d, 0x00},
+	{0x2C, 0x71e, 0x10},
+	{0x2C, 0x71f, 0x90},
+	{0x44, 0x71c, 0xF0}, /* Widget node DMIC-1 enable */
+	{0x44, 0x71d, 0x00},
+	{0x44, 0x71e, 0xA0},
+	{0x44, 0x71f, 0x90},
+	{} /* terminator */
+};
+
+static const struct hda_fixup cs8409_fixups[] = {
+	[DELL_BULLSEYE] = {
+		.type = HDA_FIXUP_PINS,
+		.v.pins = cs8409_pincfgs,
+	},
+	[DELL_WARLOCK] = {
+		.type = HDA_FIXUP_PINS,
+		.v.pins = cs8409_pincfgs,
+	},
+	[DELL_CYBORG] = {
+		.type = HDA_FIXUP_PINS,
+		.v.pins = cs8409_pincfgs,
+	},
+	[UPXTREME_CDB42L42] = {
+		.type = HDA_FIXUP_PINS,
+		.v.pins = cs8409_pincfgs,
+		.chain_id = CS8409_VERBS,
+	},
+	[CS8409_VERBS] = {
+		.type = HDA_FIXUP_VERBS,
+		.v.verbs = cs8409_verbs,
+	},
+};
+
+/* CS42L42 initial registers setup */
+static const struct cs8409_i2c_param cs42l42_init_seq[] = {
+		{ 0x1010, 0xB0 }, /* MAS_I2C_NACK=1, MAS_TO_DIS=0, MAS_TO_SEL=11, ACC_TO_DIS=0, ACC_TO_SEL=000 [REED-832] */
+		{ 0x1D01, 0x00 }, /* ADC_MODE=00 (auto)	[requires REED-800 patch enabled in driver] */
+		{ 0x1D02, 0x06 }, /* ADC_SOFTRAMP_EN=1 */
+		{ 0x1107, 0x01 }, /* SCLK_PRESENT=1 */
+		{ 0x1009, 0x02 }, /* MCLKDIV=000, INTERNAL_FS=1, SCLK_DIS=0 */
+		{ 0x1007, 0x03 }, /* EQ_BYPASS=0, I2C_DRIVE=0, ASP_DRIVE=0, SRC_BYPASS_DAC=1, SRC_BYPASS_ADC=1 */
+		{ 0x1201, 0x00 }, /* MCLKDIV=0, MCLK_SRC_SEL=0 (SCLK) */
+		{ 0x1208, 0x13 }, /* ASP_STP=1, ASP_5050=0, ASP_FSD=011 */
+		{ 0x1205, 0xFF }, /* FSYNC_PERIOD_LB=FFh must set FSYNC_PERIOD, otherwise reports ASP_RX/TX errors and TX data are incorrect */
+		{ 0x1206, 0x00 }, /* FSYNC_PERIOD_UB=00h */
+		{ 0x1207, 0x20 }, /* ASP_SCLK_EN=1, ASP_HYBRID_MODE=0, ASP_SCPOL_IN_ADC/DAC=0, ASP_LCPOL_OUT/IN=0 must set SCLK_EN, otherwise ASP is non-functional */
+		{ 0x1202, 0x0D }, /* SPDIF_CLK_DIV=001, SPDIF_LRCK_SRC_SEL=1, SPDIF_LRCK_CPOL=0, SPDIF_CLK_SRC_SEL=1	must use SCLK, otherwise 130C reports spdif_txfifo errors */
+		{ 0x2A02, 0x02 }, /* ASP_RX0_CH1_AP=0, ASP_RX0_CH1_RES=10  */
+		{ 0x2A03, 0x00 }, /* ASP_RX0_CH1_BIT_ST_MSB=0 */
+		{ 0x2A04, 0x00 }, /* ASP_RX0_CH1_BIT_ST_LSB=00h */
+		{ 0x2A05, 0x02 }, /* ASP_RX0_CH2_AP=0, ASP_RX0_CH2_RES=10 */
+		{ 0x2A06, 0x00 }, /* ASP_RX0_CH2_BIT_ST_MSB=0 */
+		{ 0x2A07, 0x20 }, /* ASP_RX0_CH2_BIT_ST_LSB=20h */
+		{ 0x2A08, 0x02 }, /* ASP_RX0_CH3_AP=0, ASP_RX0_CH2_RES=10 */
+		{ 0x2A09, 0x00 }, /* ASP_RX0_CH3_BIT_ST_MSB=0 */
+		{ 0x2A0A, 0x80 }, /* ASP_RX0_CH3_BIT_ST_LSB=80h */
+		{ 0x2A0B, 0x02 }, /* ASP_RX0_CH4_AP=0, ASP_RX0_CH2_RES=10 */
+		{ 0x2A0C, 0x00 }, /* ASP_RX0_CH4_BIT_ST_MSB=0 */
+		{ 0x2A0D, 0xA0 }, /* ASP_RX0_CH4_BIT_ST_LSB=A0h */
+		{ 0x2A01, 0x0C }, /* ASP_RX1_CH_EN=00, ASP_RX0_CH_EN=0011, ASP_RX1_2FS=0, ASP_RX0_2FS=0 */
+		{ 0x2902, 0x01 }, /* ASP_TX_CH2_EN=0, ASP_TX_CH1_EN=1 */
+		{ 0x2903, 0x02 }, /* ASP_TX_CH_AP=0, ASP_TX_RES=10 */
+		{ 0x2904, 0x00 }, /* ASP_TX_BIT_ST_MSB=0 */
+		{ 0x2905, 0x00 }, /* ASP_TX_BIT_ST_LSB=00h */
+		{ 0x2901, 0x01 }, /* ASP_TX_2FS=0, ASP_TX_EN=1 */
+		{ 0x1101, 0x0A }, /* ASP_DAO_PDN=0, ASP_DAI_PDN=0, MIXER_PDN=0, EQ_PDN=0, HP_PDN=1, ADC_PDN=0, PDN_ALL=0 */
+		{ 0x1102, 0x84 }, /* PDN_OTP_CTRL=1, DISCHARGE_FILT+=0, SRC_PDN_OVERRIDE=0, ASP_DAI1_PDN=1, DAC/ADC_SRC_PDNB=0 */
+		{ 0x2301, 0x00 }, /* MIXER_CHA_VOL=00h (0 dB) */
+		{ 0x2303, 0x00 }, /* MIXER_CHB_VOL=00h (0 dB) */
+		{ 0x2302, 0x3f }, /* MIXER_ADC_VOL=3Fh (mute) */
+		{ 0x2001, 0x03 }, /* ANA_MUTE_A/B=0, FULL_SCALE_VOL=1, DRE_EN=1 */
+		{ 0x1B75, 0xB6 }, /* LATCH_TO_VP=1, HS_DETECT_LEVEL=36h */
+		{ 0x1B73, 0xE2 }, /* TIP_SENSE_CTRL=11, TIP_SENSE_INV=1, TIP_SENSE_DEBOUNCE=10 */
+		{ 0x1129, 0x01 }, /* HS_CLAMP_DISABLE=1 */
+		{ 0x1121, 0xF3 }, /* SW_REF_HSx=1, SW_HSB_FILT_HSx=1, SW_HSB_HSx=0, SW_GNDHS_HSx=1 */
+		{ 0x1103, 0x20 }, /* SW_CLK_STP_STAT_SEL=01, VPMON_PDNB=0, RING_SENSE_PDNB=0 */
+		{ 0x1105, 0x00 }, /* TS_RS_GATE=0 */
+		{ 0x1112, 0xC0 }, /* RS_INV=1, RS_PU_EN=1, RS_FALL_DBNCE_TIME=000, RS_RISE_DBNCE_TIME=000 */
+		{ 0x1113, 0x80 }, /* TS_INV=1, TS_FALL_DBNCE_TIME=000, TS_RISE_DBNCE_TIME=000 */
+		{ 0x1C03, 0xC0 }, /* HSBIAS_CAPLESS_EN=1, HSBIAS_RAMP=00 */
+		{ 0x1105, 0x00 },
+		{ 0x1112, 0xC0 },
+		{} /* Terminator */
+};
+
+/* CS8409 initial CIR(s) setup */
+static const struct cs8409_vpw_param cs8409_init_seq[] = {
+		{ 0x47, 0x00, 0xb008 }, /* CIR=00h, coeff=B008h (+PLL1/2_EN, +I2C_EN) */
+		{ 0x47, 0x01, 0x0002 }, /* CIR=01h, coeff=0002h (ASP1/2_EN = 0, ASP1_STP = 1) */
+		{ 0x47, 0x02, 0x0a80 }, /* CIR=02h, coeff=0A80h (ASP1/2_BUS_IDLE = 10, +GPIO_I2C) */
+		{ 0x47, 0x19, 0x0800 }, /* CIR=19h, coeff=0800h (ASP1.A: TX.LAP = 0, TX.LSZ = 24 bits, TX.LCS = 0) */
+		{ 0x47, 0x1a, 0x0820 }, /* CIR=1Ah, coeff=0820h (ASP1.A: TX.RAP = 0, TX.RSZ = 24 bits, TX.RCS = 32) */
+		{ 0x47, 0x29, 0x0800 }, /* CIR=29h, coeff=0800h (ASP2.A: TX.LAP = 0, TX.LSZ = 24 bits, TX.LCS = 0) */
+		{ 0x47, 0x2a, 0x2800 }, /* CIR=2Ah, coeff=2800h (ASP2.A: TX.RAP = 1, TX.RSZ = 24 bits, TX.RCS = 0) */
+		{ 0x47, 0x39, 0x0800 }, /* CIR=39h, coeff=0800h (ASP1.A: RX.LAP = 0, RX.LSZ = 24 bits, RX.LCS = 0) */
+		{ 0x47, 0x3a, 0x0800 }, /* CIR=3Ah, coeff=0800h (ASP1.A: RX.RAP = 0, RX.RSZ = 24 bits, RX.RCS = 0) */
+		{ 0x47, 0x03, 0x8000 }, /* CIR=03h, coeff=8000h (ASP1: LCHI = 00h) */
+		{ 0x47, 0x04, 0x28ff }, /* CIR=04h, coeff=28FFh (ASP1: MC/SC_SRCSEL = PLL1, LCPR = FFh) */
+		{ 0x47, 0x05, 0x0062 }, /* CIR=05h, coeff=0062h (ASP1: MCEN = 0, FSD = 011, SCPOL_IN/OUT = 0, SCDIV = 1:4) */
+		{ 0x47, 0x06, 0x801f }, /* CIR=06h, coeff=801Fh (ASP2: LCHI = 1Fh) */
+		{ 0x47, 0x07, 0x283f }, /* CIR=07h, coeff=283Fh (ASP2: MC/SC_SRCSEL = PLL1, LCPR = 3Fh) */
+		{ 0x47, 0x08, 0x805c }, /* CIR=08h, coeff=805Ch (ASP2: 5050 = 1, MCEN = 0, FSD = 010, SCPOL_IN/OUT = 1, SCDIV = 1:16) */
+		{ 0x47, 0x09, 0x0023 }, /* CIR=09h, coeff=0023h (DMIC1_MO = 10b, DMIC1/2_SR = 1) */
+		{ 0x47, 0x0a, 0x0000 }, /* CIR=0Ah, coeff=0000h (ASP1/2_BEEP = 0) */
+		{ 0x47, 0x01, 0x0062 }, /* CIR=01h, coeff=0062h (ASP1/2_EN = 1, ASP1_STP = 1) */
+		{ 0x47, 0x00, 0x9008 }, /* CIR=00h, coeff=9008h (-PLL2_EN) */
+		{ 0x47, 0x68, 0x0000 }, /* CIR=68h, coeff=0000h (TX2.A: pre-scale att. = 0 dB) */
+		{ 0x47, 0x82, 0xfc01 }, /* CIR=82h, coeff=FC01h (ASP1/2_xxx_EN = 1, ASP1/2_MCLK_EN = 0, DMIC1_SCL_EN = 1) */
+		{ 0x47, 0xc0, 0x9999 }, /* CIR=C0h, coeff=9999h (test mode on) */
+		{ 0x47, 0xc5, 0x0000 }, /* CIR=C5h, coeff=0000h [0004h] (GPIO hysteresis = 30 us) */
+		{ 0x47, 0xc0, 0x0000 }, /* CIR=C0h, coeff=0000h (test mode off) */
+		{} /* Terminator */
+};
+
+/* Enable I2C clocks */
+static inline void cs8409_enableI2Cclock(struct hda_codec *codec, unsigned int flag)
+{
+	unsigned int retval = 0;
+    unsigned int newval = 0;
+
+	retval = cs_vendor_coef_get(codec, 0x0);
+	newval = (flag) ? (retval | 0x8) : (retval & 0xfffffff7);
+	cs_vendor_coef_set(codec, 0x0, newval);
+	retval = cs_vendor_coef_get(codec, 0x0);
+}
+
+/* Wait I2C transaction  */
+static int cs8409_i2cWaitComplete(struct hda_codec *codec)
+{
+	int repeat = 5;
+	unsigned int retval = 0;
+
+	do {
+		retval = cs_vendor_coef_get(codec, 0x5c);
+		if ((retval & 0x18) != 0x18)
+		{
+			usleep_range(2000,4000);
+			--repeat;
+		}
+		else break;
+	} while(repeat);
+
+	if( repeat == 0) {
+		codec_err(codec, "%s() i2c transaction failed\n", __func__);
+		return -1;
+	}
+	return 0;
+}
+
+/* CS8409 slave i2cRead */
+static unsigned int cs8409_i2cRead(struct hda_codec *codec,
+		unsigned int i2c_address,
+		unsigned int i2c_reg,
+		unsigned int paged)
+{
+	unsigned int i2c_reg_data;
+	unsigned int retval;
+
+	cs8409_enableI2Cclock(codec, 1);
+	cs_vendor_coef_set(codec, 0x59, i2c_address);
+
+	if (paged)
+	{
+		cs_vendor_coef_set(codec, 0x5d, i2c_reg >> 8);
+		cs8409_i2cWaitComplete(codec);
+	}
+
+	i2c_reg_data = (i2c_reg << 8) & 0x0ffff;
+	cs_vendor_coef_set(codec, 0x5e, i2c_reg_data);
+	cs8409_i2cWaitComplete(codec);
+	/* Register in bits 15-8 and the data in 7-0 */
+	retval = cs_vendor_coef_get(codec, 0x5e);
+	retval &=0x0ff;
+	cs8409_enableI2Cclock(codec, 0);
+
+#ifdef CS8409_VER_DEBUG
+	codec_info(codec,"%s() 0x%04x : 0x%04x = 0x%04x", __func__,
+			i2c_address, i2c_reg, retval);
+#endif
+	return retval;
+}
+
+/* CS8409 slave i2cWrite */
+static unsigned int cs8409_i2cWrite(struct hda_codec *codec,
+		unsigned int i2c_address, unsigned int i2c_reg,
+		unsigned int i2c_data,
+		unsigned int paged)
+{
+	unsigned int retval = 0;
+	unsigned int i2c_reg_data = 0;
+
+	cs8409_enableI2Cclock(codec, 1);
+	cs_vendor_coef_set(codec, 0x59, i2c_address);
+
+	if (paged)
+	{
+		cs_vendor_coef_set(codec, 0x5d, i2c_reg >> 8);
+		cs8409_i2cWaitComplete(codec);
+	}
+
+	i2c_reg_data = ((i2c_reg << 8) & 0x0ff00) | ( i2c_data & 0x0ff);
+	cs_vendor_coef_set(codec, 0x5d, i2c_reg_data);
+
+	cs8409_i2cWaitComplete(codec);
+	cs8409_enableI2Cclock(codec, 0);
+
+#ifdef CS8409_VER_DEBUG
+    codec_info(codec, "%s() 0x%04x 0x%04x: 0x%04x %d\n",__func__,
+    		i2c_address, i2c_reg, i2c_data, paged);
+#endif
+	return retval;
+}
+
+/* Set power states D0,D2,D3,D3hot */
+static void cs8409_set_power_mode(struct hda_codec *codec, int mode)
+{
+	codec_info(codec, "%s()\n", __func__);
+
+	snd_hda_codec_write(codec, codec->core.afg,
+			0, AC_VERB_SET_POWER_STATE, mode);
+	return;
+}
+
+/* Initialise CS8409 */
+static int cs8409_init(struct hda_codec *codec)
+{
+	codec_info(codec, "%s()\n", __func__);
+
+	snd_hda_gen_init(codec);
+
+	return 0;
+}
+
+/* Run CS42L42 jack auto detect */
+static void cs8409_run_jack_autodetect(struct hda_codec *codec)
+{
+	codec_info(codec, "%s()\n", __func__);
+
+	mutex_lock(&i2cm);
+
+	/* Clear interrupts status */
+	cs8409_i2cRead(codec, CS42L42_I2C_ADDR, 0x1308, 1);
+	cs8409_i2cRead(codec, CS42L42_I2C_ADDR, 0x1b77, 1);
+
+	cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1102, 0x87, 1);
+	cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1f06, 0x86, 1);
+	cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1b74, 0x07, 1);
+	cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x131b, 0x01, 1);
+	cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1120, 0x80, 1);
+
+	/* Wait ~110ms*/
+	usleep_range(110000, 200000);
+
+	cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x111f, 0x77, 1);
+	cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1120, 0xc0, 1);
+
+	mutex_unlock(&i2cm);
+
+	/* Wait ~10ms */
+	usleep_range(10000,25000);
+
+	return;
+}
+
+void cs8409_jack_unsol_event(struct hda_codec *codec, unsigned int res)
+{
+	struct cs_spec *spec = codec->spec;
+	static int jack = 0;
+	unsigned int reg = 0;
+	int type = 0;
+	struct hda_jack_tbl *jk;
+	unsigned int gpio4 = (res & (1 << 4));
+
+	codec_info(codec, "{{{ %s() gpio4=%08x\n", __func__, gpio4);
+
+	cs8409_set_power_mode(codec,1);
+
+	/* gpio4 line goes up as a result of
+	 * reading interrupt status registers,
+	 * we are not interested.
+	 * */
+	if( gpio4 ) {
+		codec_info(codec, "}}} %s() gpio4 is set, ignoring event\n", __func__);
+		return;
+	}
+
+	mutex_lock(&i2cm);
+	/*
+	 * Interrupt from HSDET_AUTO_DONE
+	 * */
+	reg = cs8409_i2cRead(codec, CS42L42_I2C_ADDR, 0x1308, 1);
+
+   	if( reg & 0x02 ) {
+		/* Read HS type */
+		reg = cs8409_i2cRead(codec, CS42L42_I2C_ADDR, 0x1124, 1);
+		/* HS types:
+		 * 0x00 - 1 : LRGM / 0x01 - 2 : LRMG
+		 * 0x10 - 3 : LRGG / 0x11 - 4 : Optical
+		 * */
+		type = ((reg & 0x03) + 1);
+
+		codec_info(codec, "%s() HSDET_AUTO_DONE: TYPE = %d\n",__func__, type);
+		/* Clear interrupts */
+		cs8409_i2cRead(codec, CS42L42_I2C_ADDR, 0x1b7b, 1);
+		cs8409_i2cRead(codec, CS42L42_I2C_ADDR, 0x130f, 1);
+
+		mutex_unlock(&i2cm);
+
+		/* This is an error on boot, no HS!!! */
+		if(type != 4) {
+
+			spec->hs_jack = 1;
+
+			snd_hda_codec_write(codec, 0x24, 0, 0x707, 0x00000040);
+			snd_hda_codec_write(codec, 0x2c, 0, 0x707, 0x00000000);
+
+			/* Report jack detect */
+			jk = snd_hda_jack_tbl_get_mst(codec, 0x24, 0);
+
+			if(jk) {
+				codec_info(codec, "%s() SND_JACK_HEADPHONE\n",__func__);
+				snd_jack_report(jk->jack, SND_JACK_HEADPHONE);
+			}
+
+			jk = snd_hda_jack_tbl_get_mst(codec, 0x34, 0);
+
+			if(jk && !(type & 0x10)) {
+				codec_info(codec, "%s() SND_JACK_MICROPHONE\n",__func__);
+				snd_jack_report(jk->jack, SND_JACK_MICROPHONE);
+			}
+
+			codec_info(codec, "%s() }}}\n", __func__);
+
+			return;
+		}
+   	}
+	/*
+	 * Interrupt from TIP_SENSE INSERT/REMOVE
+	 * */
+
+	/* Clear interrupts */
+	cs8409_i2cRead(codec, CS42L42_I2C_ADDR, 0x1b7b, 1);
+	cs8409_i2cRead(codec, CS42L42_I2C_ADDR, 0x1308, 1);
+
+	/* Read HS status */
+	reg = cs8409_i2cRead(codec, CS42L42_I2C_ADDR, 0x130f, 1);
+	mutex_unlock(&i2cm);
+
+	codec_info(codec, "%s() reg=0x%08x\n", __func__, reg);
+
+	/* Status 0x0c - jack fully inserted */
+	if( reg == 0xc && !jack ) {
+
+		cs8409_run_jack_autodetect(codec);
+		jack = 1;
+
+	} else {
+
+		if(reg == 0) {
+
+			spec->hs_jack = 0;
+			snd_hda_codec_write(codec, 0x24, 0, 0x707, 0x00000000);
+			snd_hda_codec_write(codec, 0x2c, 0, 0x707, 0x00000040);
+
+			/* Report NO jacks */
+			jk = snd_hda_jack_tbl_get_mst(codec, 0x24, 0);
+
+			if(jk) {
+				codec_info(codec, "%s() SND_JACK_NONE\n",__func__);
+				snd_jack_report(jk->jack, 0);
+			}
+
+			jk = snd_hda_jack_tbl_get_mst(codec, 0x34, 0);
+
+			if(jk) {
+				codec_info(codec, "%s() SND_JACK_NONE\n",__func__);
+				snd_jack_report(jk->jack, 0);
+			}
+			jack = 0;
+		}
+	}
+
+	codec_info(codec, "}}} %s() HP %s\n", __func__, (jack)?"Plugged":"Unplugged");
+
+	return;
+}
+
+static int cs8409_build_controls(struct hda_codec *codec)
+{
+	int err;
+
+	codec_info(codec, "%s()\n", __func__);
+
+	/* CS8409 nid(s) 0x24 and 0x34 have no DETECT capabilities, so snd_hda_gen_build_controls()
+	 * will mark them as non detectable phantom jacks,
+	 * We have to force create these inputs with correct type before we call
+	 * snd_hda_gen_build_controls() otherwise they will not be created as input devices.
+	 *
+	 */
+	snd_hda_jack_add_kctl_mst(codec, 0x24, 0,
+			"Headphone",0, SND_JACK_HEADPHONE, 0);
+
+	snd_hda_jack_add_kctl_mst(codec, 0x34, 0,
+			"Headset Mic",0, SND_JACK_MICROPHONE , 0);
+
+	err = snd_hda_gen_build_controls(codec);
+	if (err < 0)
+		return err;
+
+	snd_hda_apply_fixup(codec, HDA_FIXUP_ACT_BUILD);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int cs8409_suspend(struct hda_codec *codec);
+#endif
+
+static const struct hda_codec_ops cs8409_patch_ops = {
+	.build_controls = cs8409_build_controls,
+	.build_pcms = snd_hda_gen_build_pcms,
+	.init = cs8409_init,
+	.free = cs_free,
+	.unsol_event = cs8409_jack_unsol_event,
+#ifdef CONFIG_PM
+	.suspend = cs8409_suspend,
+#endif
+};
+
+
+#ifdef CONFIG_PM
+/* 	Manage PDREF, when transitioning to D3hot */
+static int cs8409_suspend(struct hda_codec *codec)
+{
+	codec_info(codec, "%s()\n", __func__);
+	snd_hda_shutup_pins(codec);
+	return 0;
+}
+#endif
+
+static int cs8409_function_reset(struct hda_codec *codec)
+{
+	codec_info(codec, "%s()\n", __func__);
+
+	snd_hda_codec_write(codec,
+			codec->core.afg, 0, 0x7ff, 0x00000000);
+
+	return 0;
+}
+
+/* Placeholder for AMP(s) reset if we need it */
+static int cs8409_reset_amps(struct hda_codec *codec)
+{
+	codec_info(codec, "%s()\n", __func__);
+	return 0;
+}
+
+/* Set CS8409 for HS autodetect */
+static int cs8409_enable_jack_detect(struct hda_codec *codec)
+{
+	unsigned int reg = 0;
+
+	codec_info(codec, "%s()\n", __func__);
+
+	mutex_lock(&i2cm);
+
+	/* Set TIP_SENSE_EN for analog front-end of tip sense. */
+	cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1b70, 0x0020, 1);
+	/* Clear WAKE# */
+	cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1b71, 0x0001, 1);
+	/* Wait ~2.5ms */
+	usleep_range(2500,3000);
+	/* Set mode WAKE# output follows the combination logic directly */
+	cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1b71, 0x0020, 1);
+	/* Clear interrupts staus */
+	reg = cs8409_i2cRead(codec, CS42L42_I2C_ADDR, 0x130f, 1);
+	reg = cs8409_i2cRead(codec, CS42L42_I2C_ADDR, 0x1b7b, 1);
+	/* Enable interrupt */
+	cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1320, 0x03, 1);
+	cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1b79, 0x00, 1);
+
+	mutex_unlock(&i2cm);
+
+	return 0;
+}
+
+static void cs8409_vpw_set_processing_state(struct hda_codec *codec, int state)
+{
+	codec_info(codec, "%s() state=%d\n", __func__, state);
+	snd_hda_codec_write(codec, 0x47,
+			0, AC_VERB_SET_PROC_STATE, state);
+	return;
+}
+
+/* Enable Unsolicited Response for gpio(s) 3,4 */
+static int cs8409_enable_ur(struct hda_codec *codec, int flag)
+{
+	codec_info(codec, "%s() %d\n", __func__, flag);
+
+	if( flag ) {
+		/* Enable and unmask GPIO4 INT# and GPIO3 WAKE# UR(s) */
+		snd_hda_codec_write(codec, codec->core.afg, 0, 0x708, 0x080);
+		snd_hda_codec_write(codec, codec->core.afg, 0, 0x719, 0x018);
+	} else {
+		/* Disable UR(s) */
+		snd_hda_codec_write(codec, codec->core.afg, 0, 0x708, 0x0000);
+		snd_hda_codec_write(codec, codec->core.afg, 0, 0x719, 0x0000);
+	}
+	return 0;
+}
+
+/* Assert/release RTS# line to CS42L42 */
+static void cs8409_reset_cs42l42(struct hda_codec *codec)
+{
+	codec_info(codec, "%s()\n", __func__);
+
+	/* Assert RTS# line */
+	snd_hda_codec_write(codec,
+			codec->core.afg, 0, AC_VERB_SET_GPIO_DATA, 0x00000000);
+	/* wait ~100ms */
+	usleep_range(100000,150000);
+	/* Release RTS# line */
+	snd_hda_codec_write(codec,
+			codec->core.afg, 0, AC_VERB_SET_GPIO_DATA, 0x00000020);
+	/* wait ~100ms */
+	usleep_range(100000,150000);
+
+	return;
+}
+
+static int cs8409_hp_power_up(struct hda_codec *codec)
+{
+	struct cs_spec *spec = codec->spec;
+
+	codec_info(codec, "%s()\n", __func__);
+
+	mutex_lock(&pcmm);
+
+	if(!spec->pcm_playback) {
+
+		codec_info(codec, "Enable ASP\n");
+
+		mutex_lock(&i2cm);
+		cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1101, 0x02,1);
+		mutex_unlock(&i2cm);
+
+	} else
+		codec_info(codec, "ASP is already enabled, ignore...\n");
+
+	mutex_unlock(&pcmm);
+
+	return 0;
+}
+
+static int cs8409_hp_power_down(struct hda_codec *codec)
+{
+	struct cs_spec *spec = codec->spec;
+
+	codec_info(codec, "%s()\n", __func__);
+
+	mutex_lock(&pcmm);
+
+	if( !spec->pcm_playback ) {
+
+		codec_info(codec, "Disable ASP\n");
+
+		mutex_lock(&i2cm);
+		cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1101, 0x0a, 1);
+		mutex_unlock(&i2cm);
+
+	} else
+		codec_info(codec, "Playback is still active, ignoring...\n");
+
+	mutex_unlock(&pcmm);
+
+	return 0;
+
+}
+
+static void cs8409_playback_pcm_hook(struct hda_pcm_stream *hinfo,
+				   struct hda_codec *codec,
+				   struct snd_pcm_substream *substream,
+				   int action)
+{
+	struct cs_spec *spec = codec->spec;
+
+	codec_info(codec, "%s() action=%d, nid=%04x (0)\n", __func__,  action, hinfo->nid);
+
+	switch(action) {
+
+	case HDA_GEN_PCM_ACT_PREPARE:
+
+		/* TODO: For now just base on HS status, needs to be fixed */
+		if(!spec->hs_jack) {
+			snd_hda_codec_write(codec, 0x24, 0, 0x707, 0x00000000);
+			snd_hda_codec_write(codec, 0x2c, 0, 0x707, 0x00000040);
+		} else {
+			snd_hda_codec_write(codec, 0x24, 0, 0x707, 0x00000040);
+			snd_hda_codec_write(codec, 0x2c, 0, 0x707, 0x00000000);
+		}
+
+		mutex_lock(&i2cm);
+		/* MIXER_CHA_VOL=00h (0 dB) */
+		cs8409_i2cWrite(codec, CS42L42_I2C_ADDR,0x2301,0x00,1);
+		/* MIXER_CHB_VOL=00h (0 dB) */
+		cs8409_i2cWrite(codec, CS42L42_I2C_ADDR,0x2303,0x00,1);
+		mutex_unlock(&i2cm);
+
+		cs8409_hp_power_up(codec);
+		spec->pcm_playback = 1;
+
+		break;
+
+	case HDA_GEN_PCM_ACT_CLEANUP:
+
+		snd_hda_codec_write(codec, 0x24, 0, 0x707, 0x00000040);
+		snd_hda_codec_write(codec, 0x2c, 0, 0x707, 0x00000040);
+
+		mutex_lock(&i2cm);
+		/* MIXER_CHA_VOL=3Fh (mute) */
+		cs8409_i2cWrite(codec, CS42L42_I2C_ADDR,0x2301,0x3f,1);
+		/* MIXER_CHB_VOL=3Fh (mute) */
+		cs8409_i2cWrite(codec, CS42L42_I2C_ADDR,0x2303,0x3f,1);
+		mutex_unlock(&i2cm);
+
+		spec->pcm_playback = 0;
+		cs8409_hp_power_down(codec);
+
+		break;
+
+	default:
+		break;
+
+	}
+	return;
+}
+
+static void cs8409_capture_pcm_hook(struct hda_pcm_stream *hinfo,
+				  struct hda_codec *codec,
+				  struct snd_pcm_substream *substream,
+				  int action)
+{
+	codec_info(codec, "%s() action=%d, nid=%04x\n", __func__,  action, hinfo->nid);
+
+	switch(action) {
+
+		case HDA_GEN_PCM_ACT_PREPARE:
+
+			/* TODO: For now just base on HS status, needs to be fixed */
+			mutex_lock(&i2cm);
+			/* MIXER_ADC_VOL=00h (0 dB) */
+			cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x2302, 0x00,1);
+			mutex_unlock(&i2cm);
+
+			cs8409_hp_power_up(codec);
+			break;
+
+		case HDA_GEN_PCM_ACT_CLEANUP:
+
+			mutex_lock(&i2cm);
+			/* MIXER_ADC_VOL=3Fh (mute) */
+			cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x2302, 0x3f,1);
+			mutex_unlock(&i2cm);
+
+			cs8409_hp_power_down(codec);
+			break;
+
+		default:
+			break;
+	}
+	return;
+}
+
+static void cs8409_init_cirs(struct hda_codec *codec,
+		const struct cs8409_vpw_param *seq)
+{
+	codec_info(codec, "%s()\n", __func__);
+
+	/* set power state D0 */
+	cs8409_set_power_mode(codec, 0);
+	/* set VPF */
+	cs8409_vpw_set_processing_state(codec, 1);
+
+	for (; seq->nid; seq++)
+		cs_vendor_coef_set(codec, seq->cir, seq->coeff);
+
+	  return;
+}
+
+static void cs8409_init_cs42l42(struct hda_codec *codec,
+		const struct cs8409_i2c_param* seq)
+{
+	struct cs_spec *spec = codec->spec;
+
+	codec_info(codec, "%s()\n", __func__);
+
+	mutex_lock(&i2cm);
+
+	for (; seq->addr; seq++)
+		cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, seq->addr, seq->reg, 1);
+
+	codec_info(codec, "%s() TIP_SENCE inverted %d\n", __func__, spec->ts_invert);
+
+	if(codec->fixup_id == UPXTREME_CDB42L42)
+		cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1B73, 0xE2, 1);
+	else
+		cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1B73, 0xC2, 1);
+
+	/* ADC_DIG_BOOST=1, ADC_FORCE_WEAK_VCM=1, ADC_INV=0 */
+	cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1d01, spec->hs_adc_boost, 1);
+	/* ADC_VOL=0011 1111 ( +12dB ) */
+	cs8409_i2cWrite(codec, CS42L42_I2C_ADDR, 0x1d03, spec->hs_adc_volume, 1);
+
+	mutex_unlock(&i2cm);
+
+	return;
+}
+
+/* Configuration on boot */
+static int cs8409_on_boot(struct hda_codec *codec)
+{
+	codec_info(codec, "%s()\n", __func__);
+
+	/* set power state D0 */
+	cs8409_set_power_mode(codec, 1);
+	/* Disable UR during boot */
+	cs8409_enable_ur(codec,0);
+	/* Initialise CS8409 */
+	cs8409_init_cirs(codec, cs8409_init_seq);
+	/* Reset CS42L42 */
+	cs8409_reset_cs42l42(codec);
+	/* Initialise CS42L42 */
+	cs8409_init_cs42l42(codec, cs42l42_init_seq);
+	/* Reset AMPs */
+	cs8409_reset_amps(codec);
+	/* Enable UR */
+	cs8409_enable_ur(codec,1);
+	/* Enable auto jack tetect */
+	cs8409_enable_jack_detect(codec);
+	usleep_range(1000,1500);
+	/* Run autodetect */
+	cs8409_run_jack_autodetect(codec);
+
+	return 0;
+}
+
+static int patch_cs8409(struct hda_codec *codec)
+{
+	struct cs_spec *spec;
+	int err;
+
+	codec_info(codec, "%s()\n", __func__);
+
+	spec = cs_alloc_spec(codec, CS8409_VENDOR_NID);
+	if (!spec)
+		return -ENOMEM;
+
+	spec->gen.beep_nid = 0x46;
+	spec->gen.pcm_playback_hook = cs8409_playback_pcm_hook;
+	spec->gen.pcm_capture_hook = cs8409_capture_pcm_hook;
+
+	codec->patch_ops = cs8409_patch_ops;
+
+	cs8409_function_reset(codec);
+
+	usleep_range(25000,50000);
+
+	cs8409_set_power_mode(codec, 1);
+
+	/* Initial cs8409 verbs configuration */
+	snd_hda_sequence_write(codec, cs8409_init_verbs);
+	/* ADC_DIG_BOOST=1,
+	 * ADC_FORCE_WEAK_VCM=1,
+	 * ADC_INV=0 */
+	// --VCM, ++BOOST
+	spec->hs_adc_boost = 0x0001;
+	/* ADC_VOL=0000 0000 0dB */
+	spec->hs_adc_volume = 0x0000;
+	spec->hs_jack = 0;
+
+	snd_hda_add_verbs(codec, cs8409_verbs);
+
+	codec_info(codec, "Vendor = %08x, id = %08x, subid=%08x\n",
+			codec->bus->pci->subsystem_vendor,
+			codec->bus->pci->subsystem_device,
+			codec->core.subsystem_id);
+
+	snd_hda_pick_fixup(codec, cs8409_models, cs8409_fixup_tbl,
+			   cs8409_fixups);
+
+	/* UPXTREME_CDB42L42 board
+	 * TIP_SENSE pin is inverted */
+	if(codec->fixup_id == UPXTREME_CDB42L42)
+		spec->ts_invert = 1;
+
+	codec_info(codec,"picked fixups id=%d, name=%s, ts_inv=%d\n",
+			codec->fixup_id, codec->fixup_name, spec->ts_invert);
+
+	snd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);
+
+	err = snd_hda_parse_pin_defcfg(codec, &spec->gen.autocfg, 0, 0);
+	if (err < 0)
+		goto error;
+
+	err = snd_hda_gen_parse_auto_config(codec, &spec->gen.autocfg);
+	if (err < 0)
+		goto error;
+
+	snd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);
+
+	mutex_init(&i2cm);
+	mutex_init(&pcmm);
+
+	cs8409_on_boot(codec);
+
+	return 0;
+
+ error:
+	cs_free(codec);
+	return err;
+}
 
 /*
  * patch entries
@@ -1229,6 +2199,7 @@
 	HDA_CODEC_ENTRY(0x10134208, "CS4208", patch_cs4208),
 	HDA_CODEC_ENTRY(0x10134210, "CS4210", patch_cs4210),
 	HDA_CODEC_ENTRY(0x10134213, "CS4213", patch_cs4213),
+	HDA_CODEC_ENTRY(0x10138409, "CS8409", patch_cs8409),
 	{} /* terminator */
 };
 MODULE_DEVICE_TABLE(hdaudio, snd_hda_id_cirrus);
