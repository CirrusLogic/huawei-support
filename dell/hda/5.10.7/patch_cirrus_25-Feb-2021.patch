diff -Naur ./sound/pci/hda/hda_auto_parser.h ../../linux/sound/pci/hda/hda_auto_parser.h
--- ./sound/pci/hda/hda_auto_parser.h	2021-01-12 19:18:27.000000000 +0000
+++ ../../linux/sound/pci/hda/hda_auto_parser.h	2021-02-24 18:07:35.684005998 +0000
@@ -27,7 +27,7 @@
 };
 
 #define AUTO_CFG_MAX_OUTS	HDA_MAX_OUTS
-#define AUTO_CFG_MAX_INS	8
+#define AUTO_CFG_MAX_INS	18
 
 struct auto_pin_cfg_item {
 	hda_nid_t pin;
diff -Naur ./sound/pci/hda/hda_codec.c ../../linux/sound/pci/hda/hda_codec.c
--- ./sound/pci/hda/hda_codec.c	2021-01-12 19:18:27.000000000 +0000
+++ ../../linux/sound/pci/hda/hda_codec.c	2021-02-24 18:32:37.908038736 +0000
@@ -4,6 +4,7 @@
  *
  * Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
  */
+#define DEBUG 1
 
 #include <linux/init.h>
 #include <linux/delay.h>
diff -Naur ./sound/pci/hda/hda_generic.c ../../linux/sound/pci/hda/hda_generic.c
--- ./sound/pci/hda/hda_generic.c	2021-01-12 19:18:27.000000000 +0000
+++ ../../linux/sound/pci/hda/hda_generic.c	2021-02-24 18:32:37.900038819 +0000
@@ -6,6 +6,7 @@
  *
  * Copyright (c) 2004 Takashi Iwai <tiwai@suse.de>
  */
+#define DEBUG 1
 
 #include <linux/init.h>
 #include <linux/slab.h>
diff -Naur ./sound/pci/hda/hda_local.h ../../linux/sound/pci/hda/hda_local.h
--- ./sound/pci/hda/hda_local.h	2021-01-12 19:18:27.000000000 +0000
+++ ../../linux/sound/pci/hda/hda_local.h	2021-02-24 18:07:35.684005998 +0000
@@ -180,7 +180,7 @@
 /*
  * input MUX helper
  */
-#define HDA_MAX_NUM_INPUTS	16
+#define HDA_MAX_NUM_INPUTS	36
 struct hda_input_mux_item {
 	char label[32];
 	unsigned int index;
diff -Naur ./sound/pci/hda/patch_cirrus.c ../../linux/sound/pci/hda/patch_cirrus.c
--- ./sound/pci/hda/patch_cirrus.c	2021-01-12 19:18:27.000000000 +0000
+++ ../../linux/sound/pci/hda/patch_cirrus.c	2021-02-25 10:46:39.307082988 +0000
@@ -4,11 +4,14 @@
  *
  * Copyright (c) 2009 Takashi Iwai <tiwai@suse.de>
  */
+#define DEBUG 1
 
 #include <linux/init.h>
 #include <linux/slab.h>
 #include <linux/module.h>
 #include <sound/core.h>
+#include <linux/mutex.h>
+#include <linux/pci.h>
 #include <sound/tlv.h>
 #include <sound/hda_codec.h>
 #include "hda_local.h"
@@ -37,6 +40,14 @@
 	/* for MBP SPDIF control */
 	int (*spdif_sw_put)(struct snd_kcontrol *kcontrol,
 			    struct snd_ctl_elem_value *ucontrol);
+
+	unsigned int cs42l42_hp_jack_in:1;
+	unsigned int cs42l42_mic_jack_in:1;
+
+	/* verb exec op override */
+	int (*exec_verb)(struct hdac_device *dev, unsigned int cmd,
+				 unsigned int flags, unsigned int *res);
+
 };
 
 /* available models with CS420x */
@@ -1219,6 +1230,1015 @@
 	return err;
 }
 
+/* Cirrus Logic CS8409 HDA bridge with
+ * companion chip CS42L42 */
+
+#define CS8409_VENDOR_NID 0x47
+
+#define DEBUG_CS24L42_I2C
+
+#define CS8409_CS42L42_HP_PIN_NID	0x24
+#define CS8409_CS42L42_SPK_PIN_NID	0x2c
+#define CS8409_CS42L42_AMIC_PIN_NID	0x34
+#define CS8409_CS42L42_DMIC_PIN_NID	0x44
+#define CS8409_CS42L42_DMIC_ADC_PIN_NID	0x22
+
+static struct mutex cs8409_i2c_mux;
+
+#define SLAVE_HSDET_AUTO_DONE	0x02
+#define SLAVE_HSTYPE_MASK		0x03
+
+#define SLAVE_JACK_INSERTED	0x0C
+#define SLAVE_JACK_REMOVED	0x00
+
+#define GPIO3_INT (1 << 3)
+#define GPIO4_INT (1 << 4)
+#define GPIO5_INT (1 << 5)
+
+#define CS42L42_I2C_ADDR	(0x48 << 1)
+#define TAS5825_I2C_ADDR	(0x4c << 1)
+
+#define CIR_I2C_ADDR	0x0059
+#define CIR_I2C_DATA	0x005A
+#define CIR_I2C_CTRL	0x005B
+#define CIR_I2C_STATUS	0x005C
+#define CIR_I2C_QWRITE	0x005D
+#define CIR_I2C_QREAD	0x005E
+
+struct cs8409_i2c_param {
+	unsigned int addr;
+	unsigned int reg;
+};
+
+struct cs8409_cir_param {
+	unsigned int nid;
+	unsigned int cir;
+	unsigned int coeff;
+};
+
+enum {
+	CS8409_BULLSEYE,
+	CS8409_WARLOCK,
+	CS8409_CYBORG,
+	CS8409_UPXTREME,
+	CS8409_VERBS,
+};
+
+/* Dell and UP Xtreame models */
+static const struct hda_model_fixup cs8409_models[] = {
+	{ .id = CS8409_BULLSEYE, .name = "bulleseye" },
+	{ .id = CS8409_WARLOCK, .name = "warlock" },
+	{ .id = CS8409_CYBORG, .name = "cyborg" },
+	{ .id = CS8409_UPXTREME, .name = "upxtreme" },
+	{}
+};
+
+/* Dell platforms and UP Xtreame development board */
+static const struct snd_pci_quirk cs8409_fixup_tbl[] = {
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A11,
+			"Bullseye V3 14 AMD", CS8409_BULLSEYE),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A12,
+			"Bullseye N3 15 AMD", CS8409_BULLSEYE),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A23,
+			"Bullseye V3 14 TGL", CS8409_BULLSEYE),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A24,
+			"Bullseye V3 15 TGL", CS8409_BULLSEYE),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A25,
+			"Bullseye N3 15 TGL", CS8409_BULLSEYE),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A29,
+			"Bullseye V3 14 ICL", CS8409_BULLSEYE),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A2A,
+			"Bullseye V3 15 ICL", CS8409_BULLSEYE),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A2B,
+			"Bullseye N3 15 ICL", CS8409_BULLSEYE),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0AB0,
+			"Warlock N3 15 TGL", CS8409_WARLOCK),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0AB2,
+			"Warlock V3 15 TGL", CS8409_WARLOCK),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0AB1,
+			"Warlock N3 15 ICL", CS8409_WARLOCK),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0AB3,
+			"Warlock V3 15 ICL", CS8409_WARLOCK),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0AB4,
+			"Warlock N3 15 AMD", CS8409_WARLOCK),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0AB5,
+			"Warlock V3 15 AMD", CS8409_WARLOCK),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0AD9,
+			"Warlock N3 15 TGLU", CS8409_WARLOCK),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0ADA,
+			"Warlock N3 15 ICLU", CS8409_WARLOCK),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0ADB,
+			"Warlock V3 15 TGLU", CS8409_WARLOCK),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0ADC,
+			"Warlock V3 15 ICLU", CS8409_WARLOCK),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A77,
+			"Cyborg N 14 AMD", CS8409_CYBORG),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A78,
+			"Cyborg N 15 AMD", CS8409_CYBORG),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A79,
+			"Cyborg V 14 AMD", CS8409_CYBORG),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A7A,
+			"Cyborg V 15 AMD", CS8409_CYBORG),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A7D,
+			"Cyborg N 14 TGL", CS8409_CYBORG),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A7E,
+			"Cyborg N 15 TGL", CS8409_CYBORG),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A7F,
+			"Cyborg V 14 TGL", CS8409_CYBORG),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0A80,
+			"Cyborg V 15 TGL", CS8409_CYBORG),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0ADF,
+			"Cyborg N 14 TGL APO", CS8409_CYBORG),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0AE0,
+			"Cyborg N 15 TGL APO", CS8409_CYBORG),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0AE1,
+			"Cyborg V 14 TGL APO", CS8409_CYBORG),
+	SND_PCI_QUIRK(PCI_VENDOR_ID_DELL, 0x0AE2,
+			"Cyborg V 15 TGL APO", CS8409_CYBORG),
+	/* UP Xtreme with CDB42L42 board */
+	SND_PCI_QUIRK(PCI_VENDOR_ID_CIRRUS, 0x8409,
+			"UPXtreme", CS8409_UPXTREME),
+	{} /* terminator */
+};
+
+static const struct hda_verb cs8409_cs42l42_init_verbs[] = {
+	{ 0x01, AC_VERB_SET_POWER_STATE, 0x0000 },    /* AFG: D0 */
+	{ 0x01, AC_VERB_SET_GPIO_DIRECTION, 0x0020 }, /* GPIO 5 out, 3,4 in */
+	{ 0x01, AC_VERB_SET_GPIO_DATA, 0x0000 },      /* GPIO  data 0 */
+	{ 0x01, AC_VERB_SET_GPIO_MASK, 0x003f },      /* Enable GPIO */
+	{ 0x01, AC_VERB_SET_GPIO_WAKE_MASK, 0x0018 }, /* WAKE from GPIO 3,4 */
+	{ 0x47, AC_VERB_SET_PROC_STATE, 0x0001 },     /* Enable VPW processing  */
+	{ 0x47, AC_VERB_SET_COEF_INDEX, 0x0002 },     /* Configure GPIO 6,7 */
+	{ 0x47, AC_VERB_SET_PROC_COEF,  0x0080 },     /* I2C mode */
+	{ 0x47, AC_VERB_SET_COEF_INDEX, 0x005b },     /* Set I2C bus speed */
+	{ 0x47, AC_VERB_SET_PROC_COEF,  0x0200 },     /* 100kHz I2C_STO = 2 */
+	{} /* terminator */
+};
+
+static const struct hda_pintbl cs8409_cs42l42_pincfgs[] = {
+	{ 0x24, 0x042120f0 }, /* ASP-1-TX */
+	{ 0x34, 0x04a12050 }, /* ASP-1-RX */
+	{ 0x2c, 0x901000f0 }, /* ASP-2-TX */
+	{ 0x44, 0x90a00090 }, /* DMIC-1 */
+	{} /* terminator */
+};
+
+static const struct hda_verb cs8409_cs42l42_add_verbs[] = {
+	{ 0x24, 0x71c, 0xF0 }, /* Widget node ASP-1-TX */
+	{ 0x24, 0x71d, 0x20 },
+	{ 0x24, 0x71e, 0x21 },
+	{ 0x24, 0x71f, 0x04 },
+	{ 0x34, 0x71c, 0x50 }, /* Widget node ASP-1-RX0 */
+	{ 0x34, 0x71d, 0x20 },
+	{ 0x34, 0x71e, 0xa1 },
+	{ 0x34, 0x71f, 0x04 },
+	{ 0x2C, 0x71c, 0xF0 }, /* Widget node ASP-2-TX */
+	{ 0x2C, 0x71d, 0x00 },
+	{ 0x2C, 0x71e, 0x10 },
+	{ 0x2C, 0x71f, 0x90 },
+	{ 0x44, 0x71c, 0x90 }, /* Widget node DMIC-1 */
+	{ 0x44, 0x71d, 0x00 },
+	{ 0x44, 0x71e, 0xA0 },
+	{ 0x44, 0x71f, 0x90 },
+	{} /* terminator */
+};
+
+static const struct hda_fixup cs8409_fixups[] = {
+	[CS8409_BULLSEYE] = {
+		.type = HDA_FIXUP_PINS,
+		.v.pins = cs8409_cs42l42_pincfgs,
+		.chain_id = CS8409_VERBS,
+	},
+	[CS8409_WARLOCK] = {
+		.type = HDA_FIXUP_PINS,
+		.v.pins = cs8409_cs42l42_pincfgs,
+		.chain_id = CS8409_VERBS,
+	},
+	[CS8409_CYBORG] = {
+		.type = HDA_FIXUP_PINS,
+		.v.pins = cs8409_cs42l42_pincfgs,
+		.chain_id = CS8409_VERBS,
+	},
+	[CS8409_UPXTREME] = {
+		.type = HDA_FIXUP_PINS,
+		.v.pins = cs8409_cs42l42_pincfgs,
+		.chain_id = CS8409_VERBS,
+	},
+	[CS8409_VERBS] = {
+		.type = HDA_FIXUP_VERBS,
+		.v.verbs = cs8409_cs42l42_add_verbs,
+	},
+};
+
+/* Vendor specific HW configuration for CS42L42 */
+static const struct cs8409_i2c_param cs42l42_init_reg_seq[] = {
+	{ 0x1010, 0xB0 },
+	{ 0x1D01, 0x00 },
+	{ 0x1D02, 0x06 },
+	{ 0x1D03, 0x00 },
+	{ 0x1107, 0x01 },
+	{ 0x1009, 0x02 },
+	{ 0x1007, 0x03 },
+	{ 0x1201, 0x00 },
+	{ 0x1208, 0x13 },
+	{ 0x1205, 0xFF },
+	{ 0x1206, 0x00 },
+	{ 0x1207, 0x20 },
+	{ 0x1202, 0x0D },
+	{ 0x2A02, 0x02 },
+	{ 0x2A03, 0x00 },
+	{ 0x2A04, 0x00 },
+	{ 0x2A05, 0x02 },
+	{ 0x2A06, 0x00 },
+	{ 0x2A07, 0x20 },
+	{ 0x2A08, 0x02 },
+	{ 0x2A09, 0x00 },
+	{ 0x2A0A, 0x80 },
+	{ 0x2A0B, 0x02 },
+	{ 0x2A0C, 0x00 },
+	{ 0x2A0D, 0xA0 },
+	{ 0x2A01, 0x0C },
+	{ 0x2902, 0x01 },
+	{ 0x2903, 0x02 },
+	{ 0x2904, 0x00 },
+	{ 0x2905, 0x00 },
+	{ 0x2901, 0x01 },
+	{ 0x1101, 0x0A },
+	{ 0x1102, 0x84 },
+	{ 0x2301, 0x00 },
+	{ 0x2303, 0x00 },
+	{ 0x2302, 0x3f },
+	{ 0x2001, 0x03 },
+	{ 0x1B75, 0xB6 },
+	{ 0x1B73, 0xC2 },
+	{ 0x1129, 0x01 },
+	{ 0x1121, 0xF3 },
+	{ 0x1103, 0x20 },
+	{ 0x1105, 0x00 },
+	{ 0x1112, 0xC0 },
+	{ 0x1113, 0x80 },
+	{ 0x1C03, 0xC0 },
+	{ 0x1105, 0x00 },
+	{ 0x1112, 0xC0 },
+	{ 0x1101, 0x02 },
+	{} /* Terminator */
+};
+
+/* TI TAS5825 setup */
+static const struct cs8409_i2c_param tas5825_reg_init_A[] = {
+	{ 0x00, 0x00 },
+	{ 0x7f, 0x00 },
+	{ 0x03, 0x02 },
+	{ 0x01, 0x11 },
+	{ 0x00, 0x00 },
+	{ 0x7f, 0x00 },
+	{ 0x46, 0x11 },
+	{ 0x00, 0x00 },
+	{ 0x02, 0x00 },
+	{ 0x54, 0x00 },
+	{ 0x29, 0x7c },
+	{ 0x03, 0x02 },
+};
+
+static const struct cs8409_i2c_param tas5825_reg_init_B[] = {
+	{ 0x00, 0x00 },
+	{ 0x29, 0x00 },
+	{ 0x00, 0x00 },
+	{ 0x7f, 0x00 },
+	{ 0x7d, 0x11 },
+	{ 0x7e, 0xff },
+	{ 0x00, 0x01 },
+	{ 0x51, 0x05 },
+	{ 0x00, 0x02 },
+	{ 0x19, 0x80 },
+	{ 0x00, 0x00 },
+	{ 0x7f, 0x00 },
+	{ 0x03, 0x03 },
+	{ 0x00, 0x00 },
+	{ 0x7f, 0x00 },
+	{ 0x78, 0x80 },
+};
+
+/* Vendor specific hw configuration for CS42L42 */
+static const struct cs8409_cir_param cs8409_cs42l42_hw_cfg[] = {
+	{ 0x47, 0x00, 0xb008 }, /* +PLL1/2_EN, +I2C_EN */
+	{ 0x47, 0x01, 0x0002 }, /* ASP1/2_EN=0, ASP1_STP=1 */
+	{ 0x47, 0x02, 0x0a80 }, /* ASP1/2_BUS_IDLE=10, +GPIO_I2C */
+	{ 0x47, 0x19, 0x0800 }, /* ASP1.A: TX.LAP=0, TX.LSZ=24 bits, TX.LCS=0 */
+	{ 0x47, 0x1a, 0x0820 }, /* ASP1.A: TX.RAP=0, TX.RSZ=24 bits, TX.RCS=32 */
+	{ 0x47, 0x29, 0x0800 }, /* ASP2.A: TX.LAP=0, TX.LSZ=24 bits, TX.LCS=0 */
+	{ 0x47, 0x2a, 0x2800 }, /* ASP2.A: TX.RAP=1, TX.RSZ=24 bits, TX.RCS=0 */
+	{ 0x47, 0x39, 0x0800 }, /* ASP1.A: RX.LAP=0, RX.LSZ=24 bits, RX.LCS=0 */
+	{ 0x47, 0x3a, 0x0800 }, /* ASP1.A: RX.RAP=0, RX.RSZ=24 bits, RX.RCS=0 */
+	{ 0x47, 0x03, 0x8000 }, /* ASP1: LCHI = 00h */
+	{ 0x47, 0x04, 0x28ff }, /* ASP1: MC/SC_SRCSEL=PLL1, LCPR=FFh */
+	{ 0x47, 0x05, 0x0062 }, /* ASP1: MCEN=0, FSD=011, SCPOL_IN/OUT=0, SCDIV=1:4 */
+	{ 0x47, 0x06, 0x801f }, /* ASP2: LCHI=1Fh */
+	{ 0x47, 0x07, 0x283f }, /* ASP2: MC/SC_SRCSEL=PLL1, LCPR=3Fh */
+	{ 0x47, 0x08, 0x805c }, /* ASP2: 5050=1, MCEN=0, FSD=010, SCPOL_IN/OUT=1, SCDIV=1:16 */
+	{ 0x47, 0x09, 0x0023 }, /* DMIC1_MO=10b, DMIC1/2_SR=1 */
+	{ 0x47, 0x0a, 0x0000 }, /* ASP1/2_BEEP=0 */
+	{ 0x47, 0x01, 0x0062 }, /* ASP1/2_EN=1, ASP1_STP=1 */
+	{ 0x47, 0x00, 0x9008 }, /* -PLL2_EN */
+	{ 0x47, 0x68, 0x0000 }, /* TX2.A: pre-scale att.=0 dB */
+	{ 0x47, 0x82, 0xfc03 }, /* ASP1/2_xxx_EN=1, ASP1/2_MCLK_EN=0, DMIC1_SCL_EN=1 */
+	{ 0x47, 0xc0, 0x9999 }, /* test mode on */
+	{ 0x47, 0xc5, 0x0000 }, /* GPIO hysteresis = 30 us */
+	{ 0x47, 0xc0, 0x0000 }, /* test mode off */
+	{} /* Terminator */
+};
+
+/* Enable I2C clocks */
+static void cs8409_enable_i2c_clock(struct hda_codec *codec, unsigned int flag)
+{
+	unsigned int retval = 0;
+	unsigned int newval = 0;
+
+	retval = cs_vendor_coef_get(codec, 0x0);
+	newval = (flag) ? (retval | 0x8) : (retval & 0xfffffff7);
+	cs_vendor_coef_set(codec, 0x0, newval);
+}
+
+/* Wait I2C transaction  */
+static int cs8409_i2c_wait_complete(struct hda_codec *codec)
+{
+	int repeat = 5;
+	unsigned int retval = 0;
+
+	do {
+		retval = cs_vendor_coef_get(codec, CIR_I2C_STATUS);
+		if ((retval & 0x18) != 0x18) {
+			usleep_range(2000,4000);
+			--repeat;
+		}
+		else break;
+
+	} while(repeat);
+
+	return repeat > 0 ? 0 : -1;
+}
+
+/* CS8409 slave i2cRead */
+static unsigned int cs8409_i2c_read(struct hda_codec *codec,
+		unsigned int i2c_address,
+		unsigned int i2c_reg,
+		unsigned int paged)
+{
+	unsigned int i2c_reg_data;
+	unsigned int retval;
+
+	cs8409_enable_i2c_clock(codec, 1);
+	cs_vendor_coef_set(codec, CIR_I2C_ADDR, i2c_address);
+
+	if (paged) {
+		cs_vendor_coef_set(codec, CIR_I2C_QWRITE, i2c_reg >> 8);
+		if (cs8409_i2c_wait_complete(codec) == -1) {
+			codec_err(codec,
+				"%s() Paged Transaction Failed 0x%02x : 0x%04x = 0x%02x\n",
+				__func__, i2c_address, i2c_reg, retval);
+		}
+	}
+
+	i2c_reg_data = (i2c_reg << 8) & 0x0ffff;
+	cs_vendor_coef_set(codec, CIR_I2C_QREAD, i2c_reg_data);
+	if (cs8409_i2c_wait_complete(codec) == -1) {
+		codec_err(codec,"%s() Transaction Failed 0x%02x : 0x%04x = 0x%02x\n",
+			__func__, i2c_address, i2c_reg, retval);
+	}
+
+	/* Register in bits 15-8 and the data in 7-0 */
+	retval = cs_vendor_coef_get(codec, CIR_I2C_QREAD);
+	retval &=0x0ff;
+
+	cs8409_enable_i2c_clock(codec, 0);
+
+#ifdef DEBUG_CS24L42_I2C
+	codec_dbg(codec,"%s() 0x%02x : 0x%04x = 0x%02x",
+			__func__, i2c_address, i2c_reg, retval);
+#endif
+	return retval;
+}
+
+/* CS8409 slave i2cWrite */
+static unsigned int cs8409_i2c_write(struct hda_codec *codec,
+		unsigned int i2c_address, unsigned int i2c_reg,
+		unsigned int i2c_data,
+		unsigned int paged)
+{
+	unsigned int retval = 0;
+	unsigned int i2c_reg_data = 0;
+
+	cs8409_enable_i2c_clock(codec, 1);
+	cs_vendor_coef_set(codec, CIR_I2C_ADDR, i2c_address);
+
+	if (paged) {
+		cs_vendor_coef_set(codec, CIR_I2C_QWRITE, i2c_reg >> 8);
+		if (cs8409_i2c_wait_complete(codec) == -1) {
+			codec_err(codec,
+				"%s() Paged Transaction Failed 0x%02x : 0x%04x = 0x%02x\n",
+				__func__, i2c_address, i2c_reg, retval);
+		}
+	}
+
+	i2c_reg_data = ((i2c_reg << 8) & 0x0ff00) | (i2c_data & 0x0ff);
+	cs_vendor_coef_set(codec, CIR_I2C_QWRITE, i2c_reg_data);
+
+	if (cs8409_i2c_wait_complete(codec) == -1) {
+		codec_err(codec,"%s() Transaction Failed 0x%02x : 0x%04x = 0x%02x\n",
+			__func__, i2c_address, i2c_reg, retval);
+	}
+
+	cs8409_enable_i2c_clock(codec, 0);
+
+#ifdef DEBUG_CS24L42_I2C
+	codec_dbg(codec, "%s() 0x%02x 0x%04x: 0x%02x %d\n",
+			__func__, i2c_address, i2c_reg, i2c_data, paged);
+#endif
+    return retval;
+}
+
+static void cs8409_set_power_mode(struct hda_codec *codec, int mode)
+{
+	codec_dbg(codec, "%s()\n", __func__);
+
+	snd_hda_codec_write(codec, codec->core.afg,
+			0, AC_VERB_SET_POWER_STATE, mode);
+	return;
+}
+
+/* TI TAS5825 init for UPXTREME with CDB42L42 devboard */
+static int cs8409_tas5825_init(struct hda_codec *codec)
+{
+	const struct cs8409_i2c_param* seq = tas5825_reg_init_A;
+	int len = (sizeof(tas5825_reg_init_A) / sizeof(struct cs8409_i2c_param));
+	int i = 0;
+
+	codec_dbg(codec, "%s()\n", __func__);
+
+	mutex_lock(&cs8409_i2c_mux);
+
+	for(i = 0; i < len; i++, seq++)
+		cs8409_i2c_write(codec, TAS5825_I2C_ADDR, seq->addr, seq->reg, 0);
+
+	/* sleep 5ms */
+	usleep_range(5000, 5500);
+
+	seq = tas5825_reg_init_B;
+	len = (sizeof(tas5825_reg_init_B) / sizeof(struct cs8409_i2c_param));
+
+	for(i = 0; i < len; i++, seq++)
+		cs8409_i2c_write(codec, TAS5825_I2C_ADDR, seq->addr, seq->reg, 0);
+
+	mutex_unlock(&cs8409_i2c_mux);
+
+	return 0;
+}
+
+/* Assert/release RTS# line to CS42L42 */
+static void cs8409_cs42l42_reset(struct hda_codec *codec)
+{
+	codec_dbg(codec, "%s()\n", __func__);
+
+	/* Assert RTS# line */
+	snd_hda_codec_write(codec,
+			codec->core.afg, 0, AC_VERB_SET_GPIO_DATA, 0);
+	/* wait ~10ms */
+	usleep_range(10000, 15000);
+	/* Release RTS# line */
+	snd_hda_codec_write(codec,
+			codec->core.afg, 0, AC_VERB_SET_GPIO_DATA, GPIO5_INT);
+	/* wait ~100ms */
+	usleep_range(10000, 15000);
+
+	mutex_lock(&cs8409_i2c_mux);
+	/* Clear interrupts, by reading interrup status registers */
+	cs8409_i2c_read(codec, CS42L42_I2C_ADDR, 0x1308, 1);
+	cs8409_i2c_read(codec, CS42L42_I2C_ADDR, 0x1309, 1);
+	cs8409_i2c_read(codec, CS42L42_I2C_ADDR, 0x130A, 1);
+	cs8409_i2c_read(codec, CS42L42_I2C_ADDR, 0x130F, 1);
+	mutex_unlock(&cs8409_i2c_mux);
+
+	return;
+}
+
+/* Configure CS42L42 slave codec for jack autodetect */
+static int cs8409_cs42l42_enable_jack_detect(struct hda_codec *codec)
+{
+	codec_dbg(codec, "%s()\n", __func__);
+
+	mutex_lock(&cs8409_i2c_mux);
+	/* Set TIP_SENSE_EN for analog front-end of tip sense. */
+	cs8409_i2c_write(codec, CS42L42_I2C_ADDR, 0x1b70, 0x0020, 1);
+	/* Clear WAKE# */
+	cs8409_i2c_write(codec, CS42L42_I2C_ADDR, 0x1b71, 0x0001, 1);
+	/* Wait ~2.5ms */
+	usleep_range(2500,3000);
+	/* Set mode WAKE# output follows the combination logic directly */
+	cs8409_i2c_write(codec, CS42L42_I2C_ADDR, 0x1b71, 0x0020, 1);
+	/* Clear interrupts status */
+	cs8409_i2c_read(codec, CS42L42_I2C_ADDR, 0x130f, 1);
+	cs8409_i2c_read(codec, CS42L42_I2C_ADDR, 0x1b7b, 1);
+	/* Enable interrupt */
+	cs8409_i2c_write(codec, CS42L42_I2C_ADDR, 0x1320, 0x03, 1);
+	cs8409_i2c_write(codec, CS42L42_I2C_ADDR, 0x1b79, 0x00, 1);
+	mutex_unlock(&cs8409_i2c_mux);
+
+	return 0;
+}
+
+/* Enable and run CS42L42 slave codec jack auto detect */
+static void cs8409_cs42l42_run_jack_detect(struct hda_codec *codec)
+{
+	codec_dbg(codec, "%s()\n", __func__);
+
+	cs8409_set_power_mode(codec, 1);
+
+	mutex_lock(&cs8409_i2c_mux);
+	/* Clear interrupts */
+	cs8409_i2c_read(codec, CS42L42_I2C_ADDR, 0x1308, 1);
+	cs8409_i2c_read(codec, CS42L42_I2C_ADDR, 0x1b77, 1);
+
+	cs8409_i2c_write(codec, CS42L42_I2C_ADDR, 0x1102, 0x87, 1);
+	cs8409_i2c_write(codec, CS42L42_I2C_ADDR, 0x1f06, 0x86, 1);
+	cs8409_i2c_write(codec, CS42L42_I2C_ADDR, 0x1b74, 0x07, 1);
+	cs8409_i2c_write(codec, CS42L42_I2C_ADDR, 0x131b, 0x01, 1);
+	cs8409_i2c_write(codec, CS42L42_I2C_ADDR, 0x1120, 0x80, 1);
+	/* Wait ~110ms*/
+	usleep_range(110000, 200000);
+	cs8409_i2c_write(codec, CS42L42_I2C_ADDR, 0x111f, 0x77, 1);
+	cs8409_i2c_write(codec, CS42L42_I2C_ADDR, 0x1120, 0xc0, 1);
+	/* Wait ~10ms */
+	usleep_range(10000,25000);
+	mutex_unlock(&cs8409_i2c_mux);
+
+	return;
+}
+static void cs8409_cs42l42_init_seq(struct hda_codec *codec,
+		const struct cs8409_i2c_param* seq)
+{
+	codec_dbg(codec, "%s()\n", __func__);
+
+	for (; seq->addr; seq++)
+		cs8409_i2c_write(codec, CS42L42_I2C_ADDR, seq->addr, seq->reg, 1);
+
+	return;
+}
+
+/*
+ * In case of CS8409 we do not have unsol events from NID's 0x24 and 0x34
+ * where hs mic and hp are connected. Companion codec CS42L42 will generate
+ * interrupt via gpio 4 to notify jack events. We have to overwrite standard
+ * snd_hda_jack_unsol_event() and read CS42L42 jack detect registers and
+ * notify status via snd_jack_report() call
+ */
+void cs8409_jack_unsol_event(struct hda_codec *codec, unsigned int res)
+{
+	struct cs_spec *spec = codec->spec;
+	int status_changed = 0;
+	unsigned int reg_cdc_status = 0;
+	unsigned int reg_hs_status = 0;
+	unsigned int reg_ts_status = 0;
+	int type = 0;
+	struct hda_jack_tbl *jk;
+
+	codec_dbg(codec, "%s() gpio4=%08x\n",
+			__func__, (res & (1 << 4)));
+
+	cs8409_set_power_mode(codec, 1);
+
+	/* jack_unsol_event() will be called every time gpio line changing state.
+	 * In this case gpio4 line goes up as a result of reading interrupt status
+	 * registers in previous cs8409_jack_unsol_event() call.
+	 * We don't need to handle this event, ignoring...
+	 */
+	if((res & (1 << 4))) {
+		codec_dbg(codec, "%s() exit\n", __func__);
+		return;
+	}
+
+	mutex_lock(&cs8409_i2c_mux);
+
+	/* Read jack detect status registers */
+	reg_cdc_status = cs8409_i2c_read(codec, CS42L42_I2C_ADDR, 0x1308, 1);
+	reg_hs_status = cs8409_i2c_read(codec, CS42L42_I2C_ADDR, 0x1124, 1);
+	reg_ts_status = cs8409_i2c_read(codec, CS42L42_I2C_ADDR, 0x130f, 1);
+
+	/* Clear interrupts */
+	cs8409_i2c_read(codec, CS42L42_I2C_ADDR, 0x1b7b, 1);
+	cs8409_i2c_read(codec, CS42L42_I2C_ADDR, 0x130f, 1);
+	cs8409_i2c_read(codec, CS42L42_I2C_ADDR, 0x1308, 1);
+
+	mutex_unlock(&cs8409_i2c_mux);
+
+	/* HSDET_AUTO_DONE */
+	if(reg_cdc_status & SLAVE_HSDET_AUTO_DONE) {
+
+		type = ((reg_hs_status & SLAVE_HSTYPE_MASK) + 1);
+
+		codec_dbg(codec, "%s() HSDET_AUTO_DONE: TYPE = %d\n", __func__, type);
+
+		/* CS42L42 reports optical jack as type 4
+		 * We don't handle optical jack */
+		if(type != 4) {
+			if(!spec->cs42l42_hp_jack_in) {
+				status_changed = 1;
+				spec->cs42l42_hp_jack_in = 1;
+			}
+			/* type = 3 has no mic */
+			if((!spec->cs42l42_mic_jack_in) && (type != 3)) {
+				status_changed = 1;
+				spec->cs42l42_mic_jack_in = 1;
+			}
+		}
+
+	} else {
+		/* TIP_SENSE INSERT/REMOVE */
+		codec_dbg(codec, "%s() reg_ts_status=0x%08x\n",
+				__func__, reg_ts_status);
+
+		switch(reg_ts_status) {
+
+		case SLAVE_JACK_INSERTED:
+			cs8409_cs42l42_run_jack_detect(codec);
+			break;
+
+		case SLAVE_JACK_REMOVED:
+			if (spec->cs42l42_hp_jack_in || spec->cs42l42_mic_jack_in) {
+				status_changed = 1;
+				spec->cs42l42_hp_jack_in = 0;
+				spec->cs42l42_mic_jack_in = 0;
+			}
+			break;
+
+		default:
+			/* jack in transition */
+			status_changed = 0;
+			break;
+		}
+	}
+
+	if(status_changed) {
+
+		codec_dbg(codec, "%s() Jack status has changed\n", __func__);
+
+		snd_hda_set_pin_ctl(codec, CS8409_CS42L42_SPK_PIN_NID,
+				(spec->cs42l42_hp_jack_in)?0 : PIN_OUT);
+
+		/* Report jack*/
+		jk = snd_hda_jack_tbl_get_mst(codec, CS8409_CS42L42_HP_PIN_NID, 0);
+		if(jk) {
+			snd_hda_jack_unsol_event(codec,
+				(jk->tag << AC_UNSOL_RES_TAG_SHIFT) & AC_UNSOL_RES_TAG);
+		}
+		/* Report jack*/
+		jk = snd_hda_jack_tbl_get_mst(codec, CS8409_CS42L42_AMIC_PIN_NID, 0);
+		if(jk) {
+			snd_hda_jack_unsol_event(codec,
+				(jk->tag << AC_UNSOL_RES_TAG_SHIFT) & AC_UNSOL_RES_TAG);
+		}
+	}
+
+	status_changed = 0;
+
+	codec_dbg(codec, "%s() exit: HP: %s, MIC: %s\n", __func__,
+			(spec->cs42l42_hp_jack_in)?"Plugged":"Unplugged",
+			(spec->cs42l42_mic_jack_in)?"Plugged":"Unplugged");
+
+	return;
+}
+
+static int cs8409_cs42l42_build_controls(struct hda_codec *codec)
+{
+	int err;
+
+	err = snd_hda_gen_build_controls(codec);
+	if (err < 0)
+		return err;
+
+	snd_hda_apply_fixup(codec, HDA_FIXUP_ACT_BUILD);
+
+	/* Run jack auto detect first time on boot
+	 * after controls have been added, to check if jack has
+	 * been already plugged in */
+	cs8409_cs42l42_run_jack_detect(codec);
+	usleep_range(100000,150000);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+/* 	Manage PDREF, when transition to D3hot */
+static int cs8409_suspend(struct hda_codec *codec)
+{
+	codec_dbg(codec, "%s()\n", __func__);
+
+	mutex_lock(&cs8409_i2c_mux);
+	/* Power down CS42L42 ASP/EQ/MIX/HP */
+	codec_dbg(codec, "%s() Power down CS42L42\n", __func__);
+	cs8409_i2c_write(codec, CS42L42_I2C_ADDR, 0x1101, 0xfe,1);
+	mutex_unlock(&cs8409_i2c_mux);
+	snd_hda_shutup_pins(codec);
+	return 0;
+}
+#endif
+
+static void cs8409_cs42l42_cap_sync_hook(struct hda_codec *codec,
+					 struct snd_kcontrol *kcontrol,
+					 struct snd_ctl_elem_value *ucontrol)
+{
+	struct cs_spec *spec = codec->spec;
+	unsigned int curval, expval;
+	/* CS8409 DMIC Pin only allows the setting of the Stream Parameters in
+	 * Power State D0. When a headset is unplugged, and the path is switched to
+	 * the DMIC, the Stream is restarted with the new ADC, but this is done in
+	 * Power State D3. Restart the Stream now DMIC is in D0. */
+	if (spec->gen.cur_adc == CS8409_CS42L42_DMIC_ADC_PIN_NID) {
+		curval = snd_hda_codec_read(codec, spec->gen.cur_adc,
+			0, AC_VERB_GET_CONV, 0);
+		expval = (spec->gen.cur_adc_stream_tag << 4) | 0;
+		if (curval != expval) {
+			codec_dbg(codec, "%s Restarting Stream after DMIC switch\n", __func__);
+			__snd_hda_codec_cleanup_stream(codec, spec->gen.cur_adc, 1);
+			snd_hda_codec_setup_stream(codec, spec->gen.cur_adc,
+					   spec->gen.cur_adc_stream_tag, 0,
+					   spec->gen.cur_adc_format);
+		}
+    }
+
+	return;
+}
+
+/* Enable/Disable Unsolicited Response for gpio(s) 3,4 */
+static void cs8409_enable_UR(struct hda_codec *codec, int flag)
+{
+	codec_dbg(codec, "%s() %d\n", __func__, flag);
+
+	/* GPIO4 INT# and GPIO3 WAKE# */
+	snd_hda_codec_write(codec, codec->core.afg,
+			0, AC_VERB_SET_GPIO_UNSOLICITED_RSP_MASK,
+			flag?(GPIO3_INT | GPIO4_INT) : 0);
+
+	snd_hda_codec_write(codec, codec->core.afg,
+			0, AC_VERB_SET_UNSOLICITED_ENABLE,
+			flag?AC_UNSOL_ENABLED : 0);
+
+	return;
+}
+
+static int cs8409_cs42l42_init(struct hda_codec *codec)
+{
+	int ret;
+	codec_dbg(codec, "%s()\n", __func__);
+
+	ret = snd_hda_gen_init(codec);
+
+	if (!ret) {
+
+		/* Disable Unsolicited Response */
+		cs8409_enable_UR(codec, 0);
+
+		/* Reset/init and power up CS42L42 ASP/EQ/MIX/HP */
+		codec_dbg(codec, "Power up CS42L42\n");
+		/* Reset cs42l42 */
+		cs8409_cs42l42_reset(codec);
+
+		usleep_range(150000,200000);
+
+		/* Initialise CS42L42 companion codec */
+		cs8409_cs42l42_init_seq(codec, cs42l42_init_reg_seq);
+
+		mutex_lock(&cs8409_i2c_mux);
+		cs8409_i2c_write(codec, CS42L42_I2C_ADDR, 0x1101, 0x02,1);
+		mutex_unlock(&cs8409_i2c_mux);
+
+		cs8409_cs42l42_enable_jack_detect(codec);
+		/* Enable Unsolicited Response */
+		cs8409_enable_UR(codec, 1);
+
+		cs8409_cs42l42_run_jack_detect(codec);
+		usleep_range(100000,150000);
+	}
+
+	return ret;
+}
+
+static const struct hda_codec_ops cs8409_cs42l42_patch_ops = {
+	.build_controls = cs8409_cs42l42_build_controls,
+	.build_pcms = snd_hda_gen_build_pcms,
+	.init = cs8409_cs42l42_init,
+	.free = cs_free,
+	.unsol_event = cs8409_jack_unsol_event,
+#ifdef CONFIG_PM
+	.suspend = cs8409_suspend,
+#endif
+};
+
+/* Vendor specific hw configuration
+ * PLL, ASP, I2C, SPI, GPIOs, DMIC etc... */
+static int cs8409_cs42l42_on_boot(struct hda_codec *codec,
+		const struct cs8409_cir_param *seq)
+{
+	unsigned int reg = 0;
+
+	codec_dbg(codec, "%s()\n", __func__);
+
+	for (; seq->nid; seq++)
+		cs_vendor_coef_set(codec, seq->cir, seq->coeff);
+
+	/* Disable Unsolicited Response during boot */
+	cs8409_enable_UR(codec, 0);
+
+	/* Reset CS42L42 */
+	cs8409_cs42l42_reset(codec);
+
+	/* Initialise CS42L42 companion codec */
+	cs8409_cs42l42_init_seq(codec, cs42l42_init_reg_seq);
+
+	/* Required only for UPXTREME/CDB42L42 board */
+	if(codec->fixup_id == CS8409_UPXTREME) {
+		cs8409_tas5825_init(codec);
+		/* On CDB42L42 board TIP_SENSE is inverted */
+		mutex_lock(&cs8409_i2c_mux);
+		reg = cs8409_i2c_read(codec, CS42L42_I2C_ADDR, 0x1b73, 1);
+		reg |= 0x0020;
+		reg = cs8409_i2c_write(codec, CS42L42_I2C_ADDR, 0x1b73, reg, 1);
+		mutex_unlock(&cs8409_i2c_mux);
+	}
+	cs8409_cs42l42_enable_jack_detect(codec);
+
+	/* Enable Unsolicited Response */
+	cs8409_enable_UR(codec, 1);
+
+	return 1;
+}
+
+static int cs8409_cs42l42_fixup(struct hda_codec *codec,
+		const struct hda_verb *seq,
+		const struct hda_verb *verbs)
+{
+	int err = 0;
+	struct cs_spec *spec = codec->spec;
+	unsigned int pincap = 0;
+
+	codec_dbg(codec, "%s()\n", __func__);
+
+	/* Basic initial sequence for specific hw configuration */
+	snd_hda_sequence_write(codec, seq);
+
+	/* Add additional verbs for init() and resume() calls */
+	snd_hda_add_verbs(codec, verbs);
+
+	/* CS8409 is simple HDA bridge and intended to be used with a remote
+	 * companion codec. Most of input/output PIN(s) have only basic
+	 * capabilities. NID(s) 0x24 and 0x34 have only OUTC and INC
+	 * capabilities and no presence detect capable (PDC) and call to
+	 * snd_hda_gen_build_controls() will mark them as non detectable
+	 * phantom jacks. However, in this configuration companion codec
+	 * CS42L42 is connected to these pins and will have jack detect
+	 * capabilities. We have to override pin capabilities,
+	 * otherwise they will not be created as input devices.
+	 */
+	_snd_hdac_read_parm(&codec->core,
+			CS8409_CS42L42_HP_PIN_NID, AC_PAR_PIN_CAP, &pincap);
+
+	pincap |= (AC_PINCAP_IMP_SENSE | AC_PINCAP_PRES_DETECT);
+
+	snd_hdac_override_parm(&codec->core,
+			CS8409_CS42L42_HP_PIN_NID,AC_PAR_PIN_CAP, pincap);
+
+	_snd_hdac_read_parm(&codec->core, CS8409_CS42L42_AMIC_PIN_NID,
+			AC_PAR_PIN_CAP, &pincap);
+
+	pincap |= (AC_PINCAP_IMP_SENSE | AC_PINCAP_PRES_DETECT);
+
+	snd_hdac_override_parm(&codec->core,
+			CS8409_CS42L42_AMIC_PIN_NID, AC_PAR_PIN_CAP, pincap);
+
+	snd_hda_override_wcaps(codec, 0x24,
+			get_wcaps(codec, 0x24) | AC_WCAP_UNSOL_CAP);
+
+	snd_hda_override_wcaps(codec, 0x34,
+			get_wcaps(codec, 0x34) | AC_WCAP_UNSOL_CAP);
+
+	snd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PRE_PROBE);
+
+	err = snd_hda_parse_pin_defcfg(codec, &spec->gen.autocfg, 0, 0);
+	if (err < 0)
+		return err;
+
+	err = snd_hda_gen_parse_auto_config(codec, &spec->gen.autocfg);
+	if (err < 0)
+		return err;
+
+	snd_hda_apply_fixup(codec, HDA_FIXUP_ACT_PROBE);
+
+	return err;
+}
+
+static int cs8409_cs42l42_exec_verb_filter(struct hdac_device *dev,
+		unsigned int cmd, unsigned int flags, unsigned int *res)
+{
+	struct hda_codec *codec = container_of(dev, struct hda_codec, core);
+	struct cs_spec *spec = codec->spec;
+
+	unsigned int addr = 0;
+	unsigned int nid = 0;
+	unsigned int verb = 0;
+	unsigned int param = 0;
+
+	addr = ((cmd >> 28) & 0x0f);
+	nid = ((cmd >> 20) & 0x07f);
+	verb = ((cmd >> 8) & 0x0fff);
+	param = (cmd & 0x0ffff);
+
+	switch(nid) {
+
+	case CS8409_CS42L42_HP_PIN_NID:
+		if (verb == AC_VERB_GET_PIN_SENSE) {
+			*res = (spec->cs42l42_hp_jack_in)?AC_PINSENSE_PRESENCE:0;
+			return 0;
+		}
+		break;
+
+	case CS8409_CS42L42_AMIC_PIN_NID:
+		if (verb == AC_VERB_GET_PIN_SENSE) {
+			*res = (spec->cs42l42_mic_jack_in)?AC_PINSENSE_PRESENCE:0;
+			return 0;
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	return spec->exec_verb(dev, cmd, flags, res);
+}
+
+static int patch_cs8409(struct hda_codec *codec)
+{
+	struct cs_spec *spec;
+	int err = -EINVAL;
+
+	codec_dbg(codec, "%s()\n", __func__);
+
+	spec = cs_alloc_spec(codec, CS8409_VENDOR_NID);
+	if (!spec)
+		return -ENOMEM;
+
+	snd_hda_pick_fixup(codec,
+			cs8409_models, cs8409_fixup_tbl, cs8409_fixups);
+
+	switch(codec->fixup_id) {
+	/* Dell and UPXTREME patforms
+	 * with CS42L42 companion codec */
+	case CS8409_BULLSEYE:
+	case CS8409_WARLOCK:
+	case CS8409_CYBORG:
+	case CS8409_UPXTREME:
+
+		snd_hda_codec_set_name(codec, "CS8409/CS42L42");
+
+		/* verb exec op override */
+		spec->exec_verb = codec->core.exec_verb;
+		codec->core.exec_verb = cs8409_cs42l42_exec_verb_filter;
+
+		mutex_init(&cs8409_i2c_mux);
+
+		codec->patch_ops = cs8409_cs42l42_patch_ops;
+
+		spec->gen.cap_sync_hook = cs8409_cs42l42_cap_sync_hook;
+
+		spec->gen.suppress_auto_mute = 1;
+		spec->gen.no_primary_hp = 1;
+
+		spec->cs42l42_hp_jack_in = 0;
+		spec->cs42l42_mic_jack_in = 0;
+
+		err = cs8409_cs42l42_fixup(codec,
+				cs8409_cs42l42_init_verbs, cs8409_cs42l42_add_verbs);
+
+		if(codec->fixup_id == CS8409_WARLOCK
+				|| codec->fixup_id == CS8409_CYBORG) {
+
+			codec_dbg(codec,"Fix DMIC for WARLOCK & CYBORG\n");
+			/* DMIC1_MO=00b, DMIC1/2_SR=1 */
+			cs_vendor_coef_set(codec, 0x09, 0x0003);
+		}
+		if(err > 0)
+			err = cs8409_cs42l42_on_boot(codec, cs8409_cs42l42_hw_cfg);
+		break;
+
+	default:
+		codec_err(codec, "VID=%08x, DEV=%08x not supported\n",
+				codec->bus->pci->subsystem_vendor,
+				codec->bus->pci->subsystem_device);
+		break;
+	}
+	if(err < 0)
+		cs_free(codec);
+
+	return err;
+}
 
 /*
  * patch entries
@@ -1229,6 +2249,7 @@
 	HDA_CODEC_ENTRY(0x10134208, "CS4208", patch_cs4208),
 	HDA_CODEC_ENTRY(0x10134210, "CS4210", patch_cs4210),
 	HDA_CODEC_ENTRY(0x10134213, "CS4213", patch_cs4213),
+	HDA_CODEC_ENTRY(0x10138409, "CS8409", patch_cs8409),
 	{} /* terminator */
 };
 MODULE_DEVICE_TABLE(hdaudio, snd_hda_id_cirrus);
